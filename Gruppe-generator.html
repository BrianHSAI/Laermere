<!DOCTYPE html>
<html lang="da">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Gruppe Fordeler</title> <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f4f8;
            color: #333;
            overflow-x: hidden; /* Prevent horizontal scroll during animation */
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            background-color: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        }

        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
        }

        .input-section {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-bottom: 30px;
             /* Transition for smooth hiding */
            transition: opacity 0.5s ease-out, max-height 0.5s ease-out;
            overflow: hidden;
            opacity: 1;
            max-height: 1000px; /* Arbitrarily large value */
        }

        body.groups-generated .input-section {
            opacity: 0;
            max-height: 0;
            padding-top: 0;
            margin-bottom: 0;
        }


        .settings {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .setting-group {
            flex: 1;
            min-width: 200px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
        }

        select, input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
        }

        textarea {
            width: 100%;
            height: 150px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-family: inherit;
            font-size: 16px;
            resize: vertical;
        }

        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 12px 25px;
            font-size: 16px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s, opacity 0.5s ease-out;
            margin: 20px auto;
            display: block;
            font-weight: bold;
             /* Transition for smooth hiding */
            opacity: 1;
        }

        button:hover {
            background-color: #2980b9;
        }

         body.groups-generated button:not(#printGroupsButton) {
             opacity: 0;
             /* Position off-screen instead of display: none to allow transition */
             position: absolute;
             left: -9999px;
         }


        #printGroupsButton {
             background-color: #2ecc71; /* Green color for print button */
             margin-top: 0; /* Adjust margin */
             display: none; /* Initially hidden */
              /* Ensure button is visible after generation */
            position: relative !important;
            left: auto !important;
            opacity: 1 !important;
        }

        #printGroupsButton:hover {
            background-color: #27ae60;
        }


        .groups-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-top: 40px;
            justify-content: center;
        }

        body.groups-generated .groups-container {
            margin-top: 20px; /* Less space when input is hidden */
        }


        .group {
            background-color: #fff;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            flex: 1;
            min-width: 250px;
            max-width: 350px;
            transition: transform 0.5s ease-out;
            page-break-inside: avoid; /* Avoid breaking group across pages when printing */
        }

        .group h3 {
            margin-top: 0;
            border-bottom: 2px solid #3498db;
            padding-bottom: 8px;
            color: #2c3e50;
            text-align: center;
        }

        .participant {
            margin: 8px 0;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s ease;
            border-left: 4px solid transparent; /* Default border */
        }

        /* We keep gender classes for potential future use or subtle styling if needed */
        .participant.gender-m { border-left-color: #3498db; } /* Male */
        .participant.gender-k { border-left-color: #e74c3c; } /* Female */
        .participant.gender-a { border-left-color: #f1c40f; } /* Other */
        .participant.gender-none { border-left-color: #95a5a6; } /* Not specified */


        /* Stats section removed from displayGroups function */
        /* We keep the style here in case it's needed for other purposes, but it won't be added to groupsResult */
        .stats {
            margin-top: 15px;
            font-style: italic;
            color: #7f8c8d;
            font-size: 0.9em;
            text-align: center;
        }

        /* Animation Styles */
        .animation-container {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.95);
            display: none;
            z-index: 1000;
            overflow: hidden;
            perspective: 1000px; /* For 3D effects */
        }

        .dealing-area {
            position: relative;
            width: 100%;
            height: 100%;
        }

        .card {
            position: absolute;
            width: 120px;
            height: 160px;
            background-color: #f9f9f9;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            color: #333;
            backface-visibility: hidden;
            transition: transform 0.8s ease-in-out, opacity 0.8s ease-in-out;
            border: 2px solid #3498db; /* Default card border */
            box-sizing: border-box;
            padding: 10px;
            text-align: center;
            font-size: 0.9em;
            overflow: hidden;
        }

         /* Card border colors based on gender */
        .card.gender-m { border-color: #3498db; }
        .card.gender-k { border-color: #e74c3c; }
        .card.gender-a { border-color: #f1c40f; }
        .card.gender-none { border-color: #95a5a6; }

        .card .card-name {
            font-size: 1.1em;
            margin-bottom: 5px;
        }

        /* Card details are removed from displayGroups final output */
        .card .card-details {
            font-size: 0.8em;
            color: #555;
            white-space: pre-wrap; /* Allow details to wrap */
        }


        .deal-animation {
            animation: dealCard 0.8s ease-in-out forwards;
        }

        @keyframes dealCard {
            0% {
                transform: translate(0, 0) rotateY(0deg);
                opacity: 1;
            }
            50% {
                 transform: translate(var(--translate-x), var(--translate-y)) rotateY(90deg);
                 opacity: 0.8;
            }
            100% {
                transform: translate(var(--translate-x), var(--translate-y)) rotateY(0deg);
                opacity: 1;
            }
        }

        .trick-area {
            position: absolute;
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            color: white;
            font-size: 1.2em;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            align-items: flex-start;
            min-height: 200px; /* Ensure visible area */
            box-sizing: border-box;
            opacity: 0; /* Initially hidden */
            transition: opacity 0.5s ease;
        }

        .trick-area.visible {
            opacity: 1;
        }

        .trick-area h3 {
            width: 100%;
            margin-top: 0;
            color: #f1c40f;
            margin-bottom: 10px;
        }

        .trick-card {
             width: 80px;
            height: 110px;
            background-color: #f9f9f9;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            color: #333;
            border: 2px solid #3498db; /* Default trick card border */
            box-sizing: border-box;
            font-size: 0.7em;
             padding: 5px;
            text-align: center;
             overflow: hidden;
        }

         /* Trick card border colors based on gender */
        .trick-card.gender-m { border-color: #3498db; }
        .trick-card.gender-k { border-color: #e74c3c; }
        .trick-card.gender-a { border-color: #f1c40f; }
        .trick-card.gender-none { border-color: #95a5a6; }

         .trick-card .card-name {
            font-size: 1em;
            margin-bottom: 3px;
        }
        /* Trick card details are removed from displayGroups final output */
        .trick-card .card-details {
            font-size: 0.7em;
            color: #555;
             white-space: pre-wrap;
        }

        /* Print Styles */
        @media print {
            body {
                background-color: #fff; /* White background for printing */
                padding: 0; /* Remove body padding */
            }

            .container {
                box-shadow: none; /* Remove shadow in print */
                padding: 0; /* Adjust padding */
                 max-width: 100%; /* Use full width */
            }

            h1 {
                 color: #000; /* Black color for heading */
                 text-align: left; /* Align left for print */
                 margin-bottom: 20px;
            }

            /* Hide elements not needed for printing */
            .input-section,
            .settings,
            button, /* Hide all buttons in print */
            .animation-container {
                display: none !important;
            }

            #groupsResult {
                margin-top: 0; /* Adjust margin */
                flex-direction: column; /* Stack groups vertically */
                gap: 10px; /* Smaller gap between stacked groups */
            }

            .group {
                 flex: none; /* Don't use flex basis */
                 width: 100%; /* Take full width in print */
                 max-width: none; /* Remove max width restriction */
                 box-shadow: none; /* Remove shadow */
                 border: 1px solid #ccc; /* Add a light border */
                 margin-bottom: 10px; /* Add space between groups */
            }

             .group h3 {
                  border-bottom: 1px solid #ccc; /* Lighter border */
                  color: #000;
             }

             .participant {
                 background-color: #fff; /* White background for participants */
                 border-left-width: 2px; /* Thinner border */
                 /* Hide details in print */
                 justify-content: flex-start; /* Align name to start */
             }

             /* Hide participant details in print */
             .participant .details {
                 display: none;
             }

             /* Stats section removed from displayGroups function, so won't print */
             .stats {
                 color: #555; /* Darker color for stats */
             }
        }


    </style>
</head>
<body>
    <div class="container">
        <h1>🧠 Smart Gruppe Fordeler 🚀</h1> <div class="input-section">
            <div>
                <label for="participants">Navne (ét navn pr. linje, evt. med kriterier: f.eks. "Peter (m) [7] *special*" ):</label>
                <textarea id="participants" placeholder="Peter (m) [7] *special*
Anne (k) [om] *A*
Mohamed [] *B*
Sarah (k) [7]
Anders (m) [8] *special*
Lisa [om]
Thomas (m)"></textarea>
            </div>

            <div class="settings">
                <div class="setting-group">
                    <label for="groupSize">Gruppestørrelse:</label>
                    <select id="groupSize">
                        <option value="2">2 personer pr. gruppe</option>
                        <option value="3">3 personer pr. gruppe</option>
                        <option value="4" selected>4 personer pr. gruppe</option>
                        <option value="5">5 personer pr. gruppe</option>
                        <option value="6">6 personer pr. gruppe</option>
                        <option value="custom">Brugerdefineret antal grupper</option>
                    </select>
                </div>

                <div class="setting-group" id="customGroupsContainer" style="display:none">
                    <label for="customGroups">Antal grupper:</label>
                    <input type="number" id="customGroups" min="1" value="3">
                </div>

                 <div class="setting-group">
                    <label for="genderMixing">Kønsblanding (hvis angivet):</label>
                    <select id="genderMixing">
                        <option value="random" selected>Tilfældig (ingen præference)</option>
                        <option value="balanced">Balanceret (ligelig fordeling i hver gruppe)</option>
                        <option value="separate">Adskilte (primært samme køn i grupperne)</option> </select>
                </div>

                 <div class="setting-group">
                    <label for="levelMixing">Niveau blanding (hvis angivet):</label>
                    <select id="levelMixing">
                         <option value="random" selected>Tilfældig (ingen præference)</option>
                        <option value="balanced">Balanceret (spred niveauerne ud)</option>
                         <option value="similar">Lignende (hold lignende niveauer sammen)</option>
                    </select>
                </div>

                <div class="setting-group">
                    <label for="otherMixing">Andet kriterie blanding:</label>
                     <select id="otherMixing">
                         <option value="random" selected>Tilfældig (ingen præference)</option>
                        <option value="balanced">Balanceret (spred ud)</option>
                         <option value="similar">Lignende (hold lignende sammen)</option>
                    </select>
                </div>
            </div>
        </div>

        <button id="generateGroups">LAV GRUPPER!</button>

        <button id="printGroupsButton">Udskriv Grupper</button>

        <div id="groupsResult" class="groups-container"></div>
    </div>

    <div class="animation-container" id="animationContainer">
        <div class="dealing-area" id="dealingArea">
            </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const participantsTextarea = document.getElementById('participants');
            const groupSizeSelect = document.getElementById('groupSize');
            const customGroupsContainer = document.getElementById('customGroupsContainer');
            const customGroupsInput = document.getElementById('customGroups');
            const genderMixingSelect = document.getElementById('genderMixing');
            const levelMixingSelect = document.getElementById('levelMixing');
            const otherMixingSelect = document.getElementById('otherMixing');
            const generateButton = document.getElementById('generateGroups');
            const printButton = document.getElementById('printGroupsButton');
            const groupsResultDiv = document.getElementById('groupsResult');
            const animationContainer = document.getElementById('animationContainer');
            const dealingArea = document.getElementById('dealingArea');
            const body = document.body; // Reference to the body element

            // Event for showing/hiding custom groups input
            groupSizeSelect.addEventListener('change', function() {
                if (this.value === 'custom') {
                    customGroupsContainer.style.display = 'block';
                } else {
                    customGroupsContainer.style.display = 'none';
                }
            });

            // Generate Groups button click handler
            generateButton.addEventListener('click', function() {
                 console.log('Button clicked: LAV GRUPPER!');
                 body.classList.remove('groups-generated'); // Show input fields
                 printButton.style.display = 'none'; // Hide print button when regenerating

                // Parse participants
                const participantsText = participantsTextarea.value.trim();
                if (!participantsText) {
                    alert('Indtast venligst mindst ét navn!');
                    console.log('No participants entered.');
                    return;
                }

                // Extract names and criteria
                const participants = parseParticipants(participantsText);
                 console.log('Parsed participants:', participants);


                if (participants.length < 1) {
                    alert('Indtast venligst mindst ét navn!');
                     console.log('Less than 1 participant after parsing.');
                    return;
                }

                 // Determine grouping method and settings
                const genderMixing = genderMixingSelect.value;
                const levelMixing = levelMixingSelect.value;
                const otherMixing = otherMixingSelect.value;
                const groupSize = groupSizeSelect.value;

                console.log('Settings:', {genderMixing, levelMixing, otherMixing, groupSize});


                // Create groups
                let groups;
                let numGroups;

                if (groupSize === 'custom') {
                    numGroups = parseInt(customGroupsInput.value);
                    if (isNaN(numGroups) || numGroups < 1) {
                        alert('Indtast venligst et gyldigt antal grupper (minimum 1)!');
                         console.log('Invalid number of custom groups.');
                        return;
                    }
                     if (numGroups > participants.length) {
                         alert(`Du kan ikke oprette ${numGroups} grupper med kun ${participants.length} deltagere.`);
                          console.log('More groups requested than participants.');
                         return;
                     }
                     console.log('Creating groups by number:', numGroups);
                    groups = createGroups(participants, numGroups, genderMixing, levelMixing, otherMixing, 'number');
                } else {
                    const size = parseInt(groupSize);
                     if (size < 1) {
                          alert('Gruppestørrelsen skal være mindst 1!');
                          console.log('Invalid group size.');
                          return;
                     }
                     if (size > participants.length && participants.length > 0) { // Check participant count > 0
                         alert(`Du kan ikke have grupper med ${size} personer, når du kun har ${participants.length} deltagere. Vælg en mindre størrelse eller "Brugerdefineret antal grupper".`);
                          console.log('Group size larger than total participants.');
                         return;
                     } else if (participants.length === 0 && size > 0) {
                          alert('Indtast venligst mindst ét navn!');
                           console.log('No participants entered with valid size.');
                          return;
                     }
                     console.log('Creating groups by size:', size);
                    groups = createGroups(participants, size, genderMixing, levelMixing, otherMixing, 'size');
                    numGroups = groups.length; // Determine number of groups from size
                }

                console.log('Created groups:', groups);
                console.log('Number of groups:', numGroups);

                // Show animation
                 console.log('Starting animation...');
                playGroupingAnimation(participants, groups, numGroups);
            });

            // Print button click handler
            printButton.addEventListener('click', function() {
                 console.log('Print button clicked.');
                window.print(); // Trigger the browser's print function
            });


            // Parse participants from text input, including new criteria
            function parseParticipants(text) {
                const lines = text.split('\n');
                return lines.filter(line => line.trim()).map(line => {
                    const nameMatch = line.match(/^(.+?)(?:\s*\(.*?\))?(?:\s*\[.*?\])?(?:\s*\*.*?\*)?$/);
                    const name = nameMatch ? nameMatch[1].trim() : line.trim();

                    const genderMatch = line.match(/\((m|k|a)\)/i);
                    const gender = genderMatch ? genderMatch[1].toLowerCase() : 'none';

                    const levelMatch = line.match(/\[(.*?)\]/);
                    const level = levelMatch ? levelMatch[1].trim() : '';

                    const otherMatch = line.match(/\*(.*?)\*/);
                    const other = otherMatch ? otherMatch[1].trim() : '';

                    return { name, gender, level, other };
                });
            }

            // Shuffle array using Fisher-Yates algorithm
            function shuffle(array) {
                const result = [...array];
                for (let i = result.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [result[i], result[j]] = [result[j], result[i]];
                }
                return result;
            }

            // Advanced grouping function based on criteria and method
            function createGroups(participants, param, genderMixing, levelMixing, otherMixing, method) {
                console.log('Entering createGroups', {participants, param, genderMixing, levelMixing, otherMixing, method});
                 // 1. Categorize participants by all criteria
                const categories = {
                    gender: { m: [], k: [], a: [], none: [] },
                    level: {}, // Dynamically populated
                    other: {}  // Dynamically populated
                };

                participants.forEach(p => {
                    // Gender
                    if (categories.gender[p.gender]) {
                         categories.gender[p.gender].push(p);
                    } else {
                         categories.gender.none.push(p); // Fallback if gender isn't m, k, a
                    }
                    // Level
                    if (!categories.level[p.level]) categories.level[p.level] = [];
                    categories.level[p.level].push(p);
                    // Other
                    if (!categories.other[p.other]) categories.other[p.other] = [];
                    categories.other[p.other].push(p);
                });
                console.log('Categories:', categories);


                // Shuffle participants within each category pool
                Object.values(categories.gender).forEach(pool => shuffle(pool));
                // Ensure pools for level and other also exist before shuffling
                Object.keys(categories.level).forEach(key => shuffle(categories.level[key]));
                Object.keys(categories.other).forEach(key => shuffle(categories.other[key]));
                 console.log('Categories after shuffle:', categories);


                let groups = [];
                let numGroupsTarget;
                let groupSizeTarget;

                if (method === 'size') {
                    groupSizeTarget = param;
                    // Estimate number of groups based on size - initial estimate
                    numGroupsTarget = Math.max(1, Math.ceil(participants.length / groupSizeTarget));
                     console.log('Method: size', {groupSizeTarget, numGroupsTarget});
                } else { // method === 'number'
                    numGroupsTarget = param;
                    groupSizeTarget = Infinity; // No strict size limit when grouping by number
                    if (numGroupsTarget === 0) return []; // Handle 0 groups
                     console.log('Method: number', {numGroupsTarget});
                }

                // --- Distribution Logic ---

                if (genderMixing === 'separate') {
                    console.log('Gender mixing: separate');
                    // Strategy for 'Separate' gender: Try to make groups primarily from single-gender pools.
                    // This works best with method 'size' where we try to fill groups of a specific size.
                    // For method 'number', it's harder to guarantee strict separation across a fixed number of groups.
                    // We'll prioritize creating pure groups with method 'size'. For 'number', we'll distribute from a gender-sorted list.

                    if (method === 'size') {
                        console.log('Separate mixing with method size');
                        const allGenders = ['m', 'k', 'a', 'none'];
                        let remainingParticipants = [];

                        // First, try to fill groups of groupSize from each gender pool
                        allGenders.forEach(genderKey => {
                            let currentPool = categories.gender[genderKey];
                            if (!currentPool || currentPool.length === 0) return;
                            console.log(`Processing separate gender pool: ${genderKey} with ${currentPool.length} participants`);

                            while (currentPool.length >= groupSizeTarget) {
                                console.log(`Filling group of size ${groupSizeTarget} from ${genderKey} pool`);
                                const newGroup = currentPool.splice(0, groupSizeTarget); // Take participants from the pool
                                groups.push(newGroup);
                            }
                            // Add any remaining from this gender pool (less than groupSizeTarget) to remainingParticipants
                            console.log(`${currentPool.length} participants remaining in ${genderKey} pool, adding to remainingParticipants`);
                            remainingParticipants.push(...currentPool);
                        });

                         console.log('Finished filling groups from separate pools. Remaining participants:', remainingParticipants);

                        // Distribute remaining participants into existing groups
                       if (remainingParticipants.length > 0 && groups.length > 0) {
                           console.log(`Distributing ${remainingParticipants.length} remaining participants into ${groups.length} existing groups`);
                            remainingParticipants.forEach((p, i) => {
                                // Add to groups round-robin
                                groups[i % groups.length].push(p);
                            });
                             // If no groups were created but there are participants, put them in one group
                       } else if (remainingParticipants.length > 0 && groups.length === 0) {
                            console.log(`No groups created initially, putting all ${remainingParticipants.length} remaining into one group.`);
                            groups.push(remainingParticipants);
                       }


                    } else { // method === 'number' with genderMixing === 'separate'
                        console.log('Separate mixing with method number');
                        // Distribute from a gender-sorted list round-robin into numGroupsTarget groups
                        let combinedSortedByGender = [
                            ...categories.gender.m,
                            ...categories.gender.k,
                            ...categories.gender.a,
                            ...categories.gender.none
                        ];
                         // Apply a partial shuffle to break perfect patterns while keeping clusters
                        combinedSortedByGender = shufflePartially(combinedSortedByGender, 0.2);
                         console.log('Combined and partially shuffled for separate/number:', combinedSortedByGender);


                         groups = Array(numGroupsTarget).fill().map(() => []);
                         combinedSortedByGender.forEach((p, i) => {
                             groups[i % numGroupsTarget].push(p);
                         });
                         console.log('Groups after round-robin separate/number:', groups);
                    }

                } else {
                     // --- Handle Random, Balanced, Similar ---
                     console.log('Mixing: Random, Balanced, or Similar');
                     // Combine participants into a single list, potentially sorted or interspersed based on priority

                     let combinedList = [...participants]; // Start with original list
                     console.log('Initial combinedList (participants copy):', combinedList);


                     // Apply sorting/interspersed based on mixing preferences (priority: Gender > Level > Other)
                     // Only apply if the mixing is not 'random' for this criterion AND higher priority criteria were 'random'
                     if (genderMixing === 'balanced') {
                         console.log('Applying balanced gender mixing');
                         combinedList = intersperseArrays(
                             categories.gender.m,
                             categories.gender.k,
                             categories.gender.a,
                             categories.gender.none
                         );
                     } else if (genderMixing === 'similar') {
                          console.log('Applying similar gender mixing');
                          combinedList.sort((a, b) => {
                               if (a.gender < b.gender) return -1;
                               if (a.gender > b.gender) return 1;
                               return 0;
                          });
                     } else if (levelMixing === 'balanced') { // Gender is random
                          console.log('Applying balanced level mixing');
                          const sortedLevelKeys = Object.keys(categories.level).sort();
                          const levelPools = sortedLevelKeys.map(key => categories.level[key]);
                          combinedList = intersperseArrays(...levelPools);

                     } else if (levelMixing === 'similar') { // Gender is random
                         console.log('Applying similar level mixing');
                         combinedList.sort((a, b) => {
                              if (a.level < b.level) return -1;
                              if (a.level > b.level) return 1;
                              return 0;
                         });
                     } else if (otherMixing === 'balanced') { // Gender and Level are random
                          console.log('Applying balanced other mixing');
                          const sortedOtherKeys = Object.keys(categories.other).sort();
                          const otherPools = sortedOtherKeys.map(key => categories.other[key]);
                          combinedList = intersperseArrays(...otherPools);

                     } else if (otherMixing === 'similar') { // Gender and Level are random
                           console.log('Applying similar other mixing');
                           combinedList.sort((a, b) => {
                              if (a.other < b.other) return -1;
                              if (a.other > b.other) return 1;
                              return 0;
                         });
                     } else {
                         // All random or fallthrough - full shuffle
                          console.log('Applying random mixing (full shuffle)');
                         combinedList = shuffle(participants); // Start with a fresh shuffle
                     }

                     // Apply a partial shuffle after non-random sorting/interspersing to break perfect patterns
                    if (!(genderMixing === 'random' && levelMixing === 'random' && otherMixing === 'random')) {
                          console.log('Applying partial shuffle after non-random mixing');
                         combinedList = shufflePartially(combinedList, 0.3); // Apply moderate shuffle
                    } else {
                         console.log('No partial shuffle applied (all random)');
                    }
                    console.log('Combined list before final distribution:', combinedList);


                    // Distribute the combined list into groups
                    if (method === 'number') {
                         console.log('Distributing combined list with method number');
                         groups = Array(numGroupsTarget).fill().map(() => []);
                         // Round-robin distribution
                         combinedList.forEach((p, i) => {
                             groups[i % numGroupsTarget].push(p);
                         });
                          console.log('Groups after round-robin combined/number:', groups);
                    } else { // method === 'size'
                         console.log('Distributing combined list with method size');
                         groups = [];
                         for(let i = 0; i < combinedList.length; i += groupSizeTarget) {
                             groups.push(combinedList.slice(i, i + groupSizeTarget));
                         }
                          console.log('Initial groups by slice combined/size:', groups);

                         // Handle last small group if needed (distribute members)
                         if (groups.length > 1 && groups[groups.length - 1].length > 0 && groups[groups.length - 1].length < Math.max(1, groupSizeTarget - 1)) {
                              console.log('Handling small last group by distributing members');
                              const lastGroup = groups.pop();
                              lastGroup.forEach((member, idx) => {
                                   if (groups.length > 0) {
                                    groups[idx % groups.length].push(member);
                                   } else { // Should only happen if only 1 group was intended but was popped
                                       groups.push(lastGroup); // Put it back
                                   }
                              });
                              // Remove empty groups if any resulted from pop
                             groups = groups.filter(g => g.length > 0);
                             console.log('Groups after redistributing last group:', groups);

                          } else if (groups.length === 0 && combinedList.length > 0) {
                               // If somehow no groups were formed but participants exist, put them in one group
                                console.log('No groups formed, putting all participants in one group.');
                                groups.push(combinedList);
                          } else {
                              console.log('No small last group to handle or only one group exists.');
                          }
                     }
                }

                 // Final check: ensure no empty groups remain
                 groups = groups.filter(group => group.length > 0);
                 console.log('Final groups after cleanup:', groups);


                return groups;
             }

             // Helper to intersperse arrays for balanced distribution
             // Takes multiple arrays and interleaves their elements
             function intersperseArrays(...arrays) {
                console.log('In intersperseArrays with arrays:', arrays);
                const result = [];
                // Find the maximum length among all arrays
                const maxLength = Math.max(0, ...arrays.map(arr => arr.length));

                for (let i = 0; i < maxLength; i++) {
                    arrays.forEach(arr => {
                        if (i < arr.length) {
                            result.push(arr[i]);
                        }
                    });
                }
                console.log('Intersperse result:', result);
                return result;
             }

             // Helper to partially shuffle an array (shuffles a portion from the end)
             function shufflePartially(array, percentage) {
                 console.log('In shufflePartially', {array, percentage});
                const result = [...array];
                const numToShuffle = Math.floor(result.length * percentage);
                // Ensure we don't shuffle less than 0 or more than the array length
                const actualNumToShuffle = Math.max(0, Math.min(numToShuffle, result.length));

                const startIndex = result.length - actualNumToShuffle;
                 if (startIndex < 0) startIndex = 0; // Should not happen with max/min checks, but safeguard

                console.log(`Shuffling ${actualNumToShuffle} elements from index ${startIndex}`);

                // Fisher-Yates on the portion to shuffle (from startIndex to the end)
                for (let i = result.length - 1; i >= startIndex; i--) {
                    const j = startIndex + Math.floor(Math.random() * (i - startIndex + 1));
                    [result[i], result[j]] = [result[j], result[i]];
                }
                 console.log('ShufflePartially result:', result);
                return result;
             }


            // Animation and display of results
            function playGroupingAnimation(participants, groups, numGroups) {
                console.log('Entering playGroupingAnimation', {participants, groups, numGroups});
                // Clear previous results and animation area
                groupsResultDiv.innerHTML = '';
                 printButton.style.display = 'none'; // Hide print button during animation
                dealingArea.innerHTML = '';

                // Setup trick areas
                const trickAreas = [];
                // Corrected loop: added i++
                for(let i = 0; i < numGroups; i++) {
                    console.log(`Creating trick area ${i}`);
                    const trickArea = document.createElement('div');
                    trickArea.className = 'trick-area';
                    trickArea.id = `trick-area-${i}`;
                    trickArea.style.position = 'absolute'; // Positioned by JS
                     // Simple positioning - might need adjustment for many groups
                    const areaWidth = 100 / numGroups;
                    trickArea.style.width = `${areaWidth * 0.9}%`;
                    trickArea.style.left = `${areaWidth * i + areaWidth * 0.05}%`;
                    trickArea.style.top = '20%'; // Position below the top
                    trickArea.style.bottom = '10%';
                    trickArea.style.minWidth = '120px'; // Ensure minimum size
                    trickArea.style.maxWidth = '250px'; /* Adjusted max width */
                    trickArea.style.overflowY = 'auto';
                    trickArea.style.boxSizing = 'border-box';


                    const heading = document.createElement('h3');
                    heading.textContent = `Gruppe ${i + 1}`;
                    trickArea.appendChild(heading);

                    dealingArea.appendChild(trickArea);
                    trickAreas.push(trickArea);
                }
                 console.log('Trick areas created:', trickAreas);


                // Create initial cards
                const initialCardPosition = { x: window.innerWidth / 2 - 60, y: window.innerHeight / 2 - 80 }; // Center of screen
                 let cardElements = [];
                // It's better to create cards based on the FINAL group distribution order
                // so the dealing animation reflects the actual group composition sequence
                const participantsInDealOrder = groups.flat();
                 console.log('Participants in deal order (flattened groups):', participantsInDealOrder);


                participantsInDealOrder.forEach(participant => {
                    const cardElem = document.createElement('div');
                    cardElem.className = `card gender-${participant.gender}`; // Keep gender class for color
                    cardElem.style.left = `${initialCardPosition.x}px`;
                    cardElem.style.top = `${initialCardPosition.y}px`;
                    // Use a unique identifier if names can be non-unique
                    cardElem.dataset.name = participant.name;
                    cardElem.dataset.gender = participant.gender; // Store gender for card color

                    const nameSpan = document.createElement('span');
                    nameSpan.className = 'card-name';
                    nameSpan.textContent = participant.name;
                    cardElem.appendChild(nameSpan);

                     // *** REMOVED: Details span is not needed in the final card animation ***


                     // Set card border color based on gender
                     cardElem.classList.add(`gender-${participant.gender}`);


                    dealingArea.appendChild(cardElem);
                     cardElements.push(cardElem);
                });
                console.log('Initial card elements created:', cardElements);


                 // Shuffle cards visually before dealing
                 shuffleCardElements(cardElements);


                // Show animation container
                 console.log('Showing animation container');
                animationContainer.style.display = 'block';

                 // Make trick areas visible after a delay
                 setTimeout(() => {
                     console.log('Making trick areas visible');
                     trickAreas.forEach(area => area.classList.add('visible'));
                 }, 500); // Delay visibility slightly


                // Start dealing animation after a short delay
                 console.log('Starting card dealing animation...');
                setTimeout(() => {
                    dealCards(participantsInDealOrder, groups, trickAreas, cardElements);
                }, 1500); // Delay dealing start
            }

             // Function to visually shuffle card elements
             function shuffleCardElements(cardElems) {
                  console.log('In shuffleCardElements');
                  // Apply random initial positions around the center
                 cardElems.forEach((card, index) => {
                      const startX = window.innerWidth / 2 - 60;
                      const startY = window.innerHeight / 2 - 80;

                       // Stagger initial positions slightly
                       const initialOffsetX = (index % 5 - 2) * 5; // Simple stagger
                       const initialOffsetY = Math.floor(index / 5) * 5;


                      const randomX = startX + initialOffsetX + (Math.random() - 0.5) * 50; // Smaller random spread
                      const randomY = startY + initialOffsetY + (Math.random() - 0.5) * 50;
                      const randomRotation = (Math.random() - 0.5) * 20; // Smaller random rotation

                      card.style.transition = 'transform 0.5s ease-out, opacity 0.5s ease-out';
                      card.style.transform = `translate(${randomX - startX}px, ${randomY - startY}px) rotate(${randomRotation}deg)`;
                       card.style.opacity = '0.9';
                 });

                 // Reset transform and opacity after shuffling
                 setTimeout(() => {
                      console.log('Resetting card positions after initial shuffle');
                      cardElems.forEach(card => {
                           card.style.transition = 'transform 0.5s ease-out, opacity 0.5s ease-out';
                            card.style.transform = 'translate(0, 0) rotate(0deg)';
                             card.style.opacity = '1';
                      });
                 }, 500); // Allow time for shuffle animation
             }


            // Animate dealing cards to trick areas
            function dealCards(participantsInDealOrder, finalGroups, trickAreas, cardElements) {
                console.log('Entering dealCards');
                let currentIndex = 0;
                const totalCards = participantsInDealOrder.length;
                 const cardDealDelay = 150; // Delay between dealing each card
                 console.log(`Total cards to deal: ${totalCards}`);


                function dealNextCard() {
                    if (currentIndex >= totalCards) {
                        console.log('All cards dealt. Animation complete.');
                        // Animation complete, show final results after a delay
                        setTimeout(() => {
                            animationContainer.style.display = 'none';
                            displayGroups(finalGroups); // Display final groups in the main area
                             body.classList.add('groups-generated'); // Hide input fields
                             printButton.style.display = 'block'; // Show print button
                             console.log('Animation end tasks completed.');
                        }, 1000);
                        return;
                    }

                    const participantToDeal = participantsInDealOrder[currentIndex];
                    const participantName = participantToDeal.name;
                    console.log(`Dealing card ${currentIndex + 1}/${totalCards} for participant: ${participantName}`);

                    // Find the corresponding card element by name that hasn't been dealt
                     let cardElem = null;
                     // Find the element in the *current* cardElements array (as some might be removed)
                     // Iterate backwards from the end of the visible elements, or just find the first match
                     const currentVisibleCards = dealingArea.querySelectorAll('.card:not(.dealt)');
                      for(let i = 0; i < currentVisibleCards.length; i++) {
                          const card = currentVisibleCards[i];
                          if (card.dataset.name === participantName) { // && !card.classList.contains('dealt') is redundant due to querySelector
                              cardElem = card;
                              break;
                          }
                      }


                    if (!cardElem) {
                         console.warn(`Could not find card element for ${participantName}. Skipping.`);
                        currentIndex++;
                        setTimeout(dealNextCard, 0); // Skip to the next participant immediately
                        return;
                    }

                    // Find the target group/trick area for this participant in the final structure
                    let targetGroupIndex = -1;
                    for (let i = 0; i < finalGroups.length; i++) {
                        if (finalGroups[i].some(p => p.name === participantName)) {
                            targetGroupIndex = i;
                            break;
                        }
                    }

                    if (targetGroupIndex === -1) {
                        console.warn(`Could not find target group for ${participantName}. Skipping.`);
                        currentIndex++;
                         setTimeout(dealNextCard, 0); // Skip if target group not found
                        return;
                    }

                    const targetTrickArea = document.getElementById(`trick-area-${targetGroupIndex}`);
                     if (!targetTrickArea) {
                         console.error(`Target trick area ${targetGroupIndex} not found! Cannot deal ${participantName}.`);
                         currentIndex++;
                          setTimeout(dealNextCard, 0);
                         return;
                     }

                    const targetRect = targetTrickArea.getBoundingClientRect();
                    const cardRect = cardElem.getBoundingClientRect();

                    // Calculate the translation needed to move the card from its current position
                    // to the center-ish of the target trick area relative to the dealing area.
                     // Since both are fixed/absolute within animation-container, direct viewport calculation works.
                    const targetX = (targetRect.left + targetRect.width / 2) - (cardRect.left + cardRect.width / 2);
                    const targetY = (targetRect.top + 50) - (cardRect.top); // Target slightly below top to avoid overlapping heading

                     console.log(`Dealing ${participantName} to group ${targetGroupIndex + 1}. Target offset: x=${targetX}, y=${targetY}`);

                    // Apply the animation
                    cardElem.style.setProperty('--translate-x', `${targetX}px`);
                    cardElem.style.setProperty('--translate-y', `${targetY}px`);
                    cardElem.classList.add('deal-animation');

                     // Mark the card as dealt
                    cardElem.classList.add('dealt');


                    // When animation ends, add a smaller trick card to the trick area
                    cardElem.addEventListener('animationend', () => {
                        console.log(`Animation ended for ${participantName}. Adding trick card.`);
                        // Create a new element in the target group preview (trick area)
                        const trickCard = document.createElement('div');
                         // Use gender class for trick card color
                        trickCard.className = `trick-card gender-${participantToDeal.gender}`;

                         const nameSpan = document.createElement('span');
                         nameSpan.className = 'card-name';
                         nameSpan.textContent = participantToDeal.name;
                         trickCard.appendChild(nameSpan);

                         // *** REMOVED: Details span is not needed in the trick card view ***


                        targetTrickArea.appendChild(trickCard);

                        // Remove the original flying card element from the DOM after its role is done
                         cardElem.remove();
                         console.log(`Original card element for ${participantName} removed.`);


                        // Move to the next card after a short delay for visual effect
                        currentIndex++;
                        setTimeout(dealNextCard, cardDealDelay); // Small delay between dealing cards
                    }, { once: true }); // Ensure event listener is only called once

                     // Handle cases where animationend might not fire (rare) or if the element was already removed
                     // Set a timeout as a fallback to continue the dealing process
                     // This fallback logic can be complex; let's simplify it: if the card is still in the DOM and not dealt after a timeout, assume animation failed and skip.
                     setTimeout(() => {
                          // Re-find the element in case it was removed by another process
                          const currentCardInDom = dealingArea.querySelector(`.card[data-name="${participantName}"]:not(.dealt)`);
                          if (currentCardInDom) {
                               console.warn(`AnimationEnd fallback triggered for ${participantName}. Card still in DOM and not dealt. Assuming animation issue, cleaning up and skipping.`);
                               currentCardInDom.remove(); // Clean up the card element
                               // Only increment currentIndex and call dealNextCard if this participant hasn't been processed yet
                               // Check if the participant at the *current* currentIndex is still the one we expected
                               if (currentIndex < totalCards && participantsInDealOrder[currentIndex].name === participantName) {
                                    currentIndex++;
                                    dealNextCard(); // Continue the process
                               } else {
                                     console.warn(`Fallback for ${participantName} triggered, but currentIndex already moved or participant mismatch. Attempting to just continue the main loop.`);
                                     // The main loop should pick up the correct currentIndex eventually
                               }

                          } else {
                                // Card element was already removed (either by animationend or a previous fallback).
                                // No action needed for this specific fallback timeout.
                                // The main dealing process should already be moving to the next participant.
                          }
                     }, cardDealDelay + 900); // Timeout slightly longer than animation duration
                }

                // Start the dealing process
                // Initial slight delay before the first card deals
                 if (totalCards > 0) {
                     setTimeout(dealNextCard, 500);
                 } else {
                     console.log('No participants to deal.');
                     // If no participants, just show final results immediately (empty groups)
                      setTimeout(() => {
                            animationContainer.style.display = 'none';
                            displayGroups(finalGroups);
                             body.classList.add('groups-generated');
                             // Print button might not be needed if no groups? Or maybe show it?
                             // Let's show it, in case they want to print an empty state or the header.
                             printButton.style.display = 'block';
                            console.log('No participants: Animation skipped, final display shown.');
                      }, 100);
                 }

            }


            // Display final group results in the main container
            function displayGroups(groups) {
                console.log('Entering displayGroups', {groups});
                groupsResultDiv.innerHTML = '';

                groups.forEach((group, index) => {
                    const groupDiv = document.createElement('div');
                    groupDiv.className = 'group';

                    const heading = document.createElement('h3');
                    heading.textContent = `Gruppe ${index + 1}`;
                    groupDiv.appendChild(heading);

                    // *** REMOVED: Counting criteria for stats is not needed as stats are not displayed ***


                    group.forEach(participant => {
                        // *** REMOVED: Counting logic for criteria ***

                        const memberDiv = document.createElement('div');
                        memberDiv.className = `participant gender-${participant.gender}`; // Add gender class for styling (kept for border color)

                        const nameSpan = document.createElement('span');
                         nameSpan.textContent = participant.name;
                         memberDiv.appendChild(nameSpan);

                         // *** REMOVED: Details span for individual participants is not needed ***


                        groupDiv.appendChild(memberDiv);
                    });

                    // *** REMOVED: Adding stats summary is not needed ***


                    groupsResultDiv.appendChild(groupDiv);
                });
                 console.log('displayGroups completed.');
            }
        });
    </script>
</body>
</html>